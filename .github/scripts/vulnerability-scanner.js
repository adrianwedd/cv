/**
 * Enterprise Vulnerability Scanner
 * 
 * Automated security vulnerability detection system with:
 * - Dependency vulnerability scanning
 * - Code pattern analysis for security issues
 * - Configuration security assessment
 * - Infrastructure vulnerability detection
 * - Compliance checking against security standards
 * - Automated remediation suggestions
 */

const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');
const { spawn } = require('child_process');

/**
 * Vulnerability Severity Levels
 */
const VULNERABILITY_SEVERITY = {
    INFO: 0,
    LOW: 1,
    MEDIUM: 2,
    HIGH: 3,
    CRITICAL: 4
};

/**
 * Vulnerability Categories
 */
const VULNERABILITY_CATEGORIES = {
    DEPENDENCY: 'dependency',
    CODE_PATTERN: 'code_pattern',
    CONFIGURATION: 'configuration',
    INFRASTRUCTURE: 'infrastructure',
    COMPLIANCE: 'compliance',
    SECRETS: 'secrets',
    PERMISSIONS: 'permissions'
};

/**
 * Security Patterns to Detect
 */
const SECURITY_PATTERNS = {
    // Hardcoded secrets
    HARDCODED_PASSWORD: {
        pattern: /(password|pwd|pass)\s*[=:]\s*["'][^"']+["']/gi,
        severity: VULNERABILITY_SEVERITY.HIGH,
        category: VULNERABILITY_CATEGORIES.SECRETS,
        description: 'Hardcoded password detected',
        remediation: 'Use environment variables or secure vault for passwords'
    },
    
    HARDCODED_API_KEY: {
        pattern: /(api[_-]?key|apikey|access[_-]?key)\s*[=:]\s*["'][A-Za-z0-9+/=]{20,}["']/gi,
        severity: VULNERABILITY_SEVERITY.CRITICAL,
        category: VULNERABILITY_CATEGORIES.SECRETS,
        description: 'Hardcoded API key detected',
        remediation: 'Move API keys to environment variables or secrets manager'
    },
    
    HARDCODED_TOKEN: {
        pattern: /(token|bearer|auth)\s*[=:]\s*["'][A-Za-z0-9+/=]{32,}["']/gi,
        severity: VULNERABILITY_SEVERITY.CRITICAL,
        category: VULNERABILITY_CATEGORIES.SECRETS,
        description: 'Hardcoded authentication token detected',
        remediation: 'Use secure token storage and rotation'
    },
    
    // Code injection vulnerabilities
    EVAL_USAGE: {
        pattern: /\beval\s*\(/gi,
        severity: VULNERABILITY_SEVERITY.HIGH,
        category: VULNERABILITY_CATEGORIES.CODE_PATTERN,
        description: 'Dangerous eval() usage detected',
        remediation: 'Avoid eval(), use safer alternatives like JSON.parse()'
    },
    
    COMMAND_INJECTION: {
        pattern: /exec\s*\(.*process\.argv|exec\s*\(.*req\.|spawn\s*\(.*req\./gi,
        severity: VULNERABILITY_SEVERITY.CRITICAL,
        category: VULNERABILITY_CATEGORIES.CODE_PATTERN,
        description: 'Potential command injection vulnerability',
        remediation: 'Validate and sanitize all user inputs used in command execution'
    },
    
    SQL_INJECTION_RISK: {
        pattern: /query\s*\(.*\+.*\)|query\s*\(`.*\$\{.*\}`\)/gi,
        severity: VULNERABILITY_SEVERITY.HIGH,
        category: VULNERABILITY_CATEGORIES.CODE_PATTERN,
        description: 'Potential SQL injection vulnerability',
        remediation: 'Use parameterized queries and prepared statements'
    },
    
    // XSS vulnerabilities
    DANGEROUS_HTML_OUTPUT: {
        pattern: /innerHTML\s*=.*\+|innerHTML\s*=.*req\.|dangerouslySetInnerHTML/gi,
        severity: VULNERABILITY_SEVERITY.MEDIUM,
        category: VULNERABILITY_CATEGORIES.CODE_PATTERN,
        description: 'Potential XSS vulnerability in HTML output',
        remediation: 'Sanitize user input and use safe DOM manipulation methods'
    },
    
    // Insecure randomness
    WEAK_RANDOM: {
        pattern: /Math\.random\(\)/gi,
        severity: VULNERABILITY_SEVERITY.LOW,
        category: VULNERABILITY_CATEGORIES.CODE_PATTERN,
        description: 'Weak random number generation',
        remediation: 'Use crypto.randomBytes() or crypto.randomInt() for security-sensitive operations'
    },
    
    // Insecure HTTP
    INSECURE_HTTP: {
        pattern: /http:\/\/(?!localhost|127\.0\.0\.1)/gi,
        severity: VULNERABILITY_SEVERITY.MEDIUM,
        category: VULNERABILITY_CATEGORIES.CONFIGURATION,
        description: 'Insecure HTTP URL detected',
        remediation: 'Use HTTPS for all external communications'
    }
};

class VulnerabilityScanner {
    constructor(config = {}) {
        this.config = {
            scanPaths: [
                process.cwd(),
                path.join(process.cwd(), '.github'),
                path.join(process.cwd(), 'src'),
                path.join(process.cwd(), 'assets')
            ],
            excludePaths: [
                'node_modules',
                '.git',
                'dist',
                'build',
                'coverage',
                'tmp',
                'temp'
            ],
            fileExtensions: ['.js', '.ts', '.jsx', '.tsx', '.json', '.yaml', '.yml', '.env'],
            reportPath: path.join(process.cwd(), 'data', 'security-reports'),
            maxFileSize: 10 * 1024 * 1024, // 10MB
            ...config
        };
        
        this.vulnerabilities = [];
        this.scannedFiles = 0;
        this.startTime = null;
    }
    
    /**
     * Run comprehensive vulnerability scan
     */
    async runScan(options = {}) {
        this.startTime = Date.now();
        this.vulnerabilities = [];
        this.scannedFiles = 0;
        
        console.log('ðŸ” Starting comprehensive vulnerability scan...');
        
        try {
            // Create reports directory
            await fs.mkdir(this.config.reportPath, { recursive: true });
            
            // Run different scan types
            await this.scanDependencies();
            await this.scanSourceCode();
            await this.scanConfiguration();
            await this.scanSecrets();
            await this.scanPermissions();
            await this.checkCompliance();
            
            // Generate report
            const report = await this.generateReport();
            
            console.log(`âœ… Vulnerability scan completed in ${Date.now() - this.startTime}ms`);
            console.log(`   ðŸ“ Scanned ${this.scannedFiles} files`);
            console.log(`   ðŸš¨ Found ${this.vulnerabilities.length} vulnerabilities`);
            console.log(`   ðŸ“Š ${this.getVulnerabilitySummary()}`);
            
            return report;
            
        } catch (error) {
            console.error('âŒ Vulnerability scan failed:', error);
            throw error;
        }
    }
    
    /**
     * Scan dependencies for known vulnerabilities
     */
    async scanDependencies() {
        console.log('ðŸ” Scanning dependencies...');
        
        try {
            const packageJsonPath = path.join(process.cwd(), 'package.json');
            const packageLockPath = path.join(process.cwd(), 'package-lock.json');
            
            // Check if package.json exists
            try {
                await fs.access(packageJsonPath);
            } catch {
                console.log('   â„¹ï¸ No package.json found, skipping dependency scan');
                return;
            }
            
            const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf8'));
            
            // Run npm audit if package-lock.json exists
            if (await this.fileExists(packageLockPath)) {
                const auditResults = await this.runNpmAudit();
                
                if (auditResults.vulnerabilities) {
                    for (const [name, vuln] of Object.entries(auditResults.vulnerabilities)) {
                        this.addVulnerability({
                            type: VULNERABILITY_CATEGORIES.DEPENDENCY,
                            severity: this.mapNpmSeverity(vuln.severity),
                            title: `${name}: ${vuln.title}`,
                            description: vuln.overview,
                            location: `package.json (${name})`,
                            remediation: vuln.recommendation || 'Update to a secure version',
                            references: vuln.references?.map(ref => ref.url) || [],
                            cve: vuln.cves || []
                        });
                    }
                }
            }
            
            // Check for known vulnerable packages
            await this.checkVulnerablePackages(packageJson);
            
        } catch (error) {
            console.error('   âŒ Dependency scan failed:', error.message);
        }
    }
    
    /**
     * Scan source code for security patterns
     */
    async scanSourceCode() {
        console.log('ðŸ” Scanning source code...');
        
        const filesToScan = await this.getFilesToScan();
        
        for (const filePath of filesToScan) {
            try {
                const content = await fs.readFile(filePath, 'utf8');
                await this.scanFileContent(filePath, content);
                this.scannedFiles++;
            } catch (error) {
                if (error.code !== 'ENOENT') {
                    console.warn(`   âš ï¸ Failed to scan ${filePath}: ${error.message}`);
                }
            }
        }
    }
    
    /**
     * Scan file content for security patterns
     */
    async scanFileContent(filePath, content) {
        const relativePath = path.relative(process.cwd(), filePath);
        
        for (const [patternName, pattern] of Object.entries(SECURITY_PATTERNS)) {
            const matches = content.match(pattern.pattern);
            
            if (matches) {
                for (const match of matches) {
                    const lines = content.substring(0, content.indexOf(match)).split('\n');
                    const lineNumber = lines.length;
                    const line = lines[lineNumber - 1] || '';
                    
                    this.addVulnerability({
                        type: pattern.category,
                        severity: pattern.severity,
                        title: pattern.description,
                        description: `${pattern.description} in ${relativePath}:${lineNumber}`,
                        location: `${relativePath}:${lineNumber}`,
                        context: line.trim(),
                        match: match.length > 100 ? match.substring(0, 100) + '...' : match,
                        remediation: pattern.remediation,
                        pattern: patternName
                    });
                }
            }
        }
        
        // Additional context-specific checks
        await this.scanForContextualVulnerabilities(filePath, content);
    }
    
    /**
     * Scan for context-specific vulnerabilities
     */
    async scanForContextualVulnerabilities(filePath, content) {
        const relativePath = path.relative(process.cwd(), filePath);
        const ext = path.extname(filePath).toLowerCase();
        
        // Environment files
        if (filePath.includes('.env') || filePath.endsWith('.env')) {
            await this.scanEnvironmentFile(filePath, content);
        }
        
        // Configuration files
        if (['.json', '.yaml', '.yml'].includes(ext)) {
            await this.scanConfigFile(filePath, content);
        }
        
        // Dockerfile and docker-compose
        if (path.basename(filePath).toLowerCase().includes('docker')) {
            await this.scanDockerFile(filePath, content);
        }
        
        // GitHub workflows
        if (filePath.includes('.github/workflows')) {
            await this.scanGitHubWorkflow(filePath, content);
        }
    }
    
    /**
     * Scan environment files for security issues
     */
    async scanEnvironmentFile(filePath, content) {
        const lines = content.split('\n');
        
        lines.forEach((line, index) => {
            // Check for unencrypted sensitive values
            if (line.includes('=') && !line.startsWith('#')) {
                const [key, value] = line.split('=', 2);
                
                if (key && value && this.isSensitiveKey(key)) {
                    if (value.length > 10 && !value.startsWith('$')) {
                        this.addVulnerability({
                            type: VULNERABILITY_CATEGORIES.SECRETS,
                            severity: VULNERABILITY_SEVERITY.MEDIUM,
                            title: 'Potentially exposed secret in environment file',
                            description: `Sensitive key "${key}" may contain unencrypted value`,
                            location: `${path.relative(process.cwd(), filePath)}:${index + 1}`,
                            remediation: 'Use encrypted secrets or reference external secret management'
                        });
                    }
                }
            }
        });
    }
    
    /**
     * Scan configuration files
     */
    async scanConfigFile(filePath, content) {
        try {
            let config;
            const ext = path.extname(filePath).toLowerCase();
            
            if (ext === '.json') {
                config = JSON.parse(content);
            } else if (['.yaml', '.yml'].includes(ext)) {
                // Simple YAML parsing for security checks
                config = this.parseYamlBasic(content);
            }
            
            if (config) {
                await this.scanConfigObject(filePath, config);
            }
            
        } catch (error) {
            // Invalid config file format
        }
    }
    
    /**
     * Scan configuration object for security issues
     */
    async scanConfigObject(filePath, obj, keyPath = '') {
        for (const [key, value] of Object.entries(obj)) {
            const fullPath = keyPath ? `${keyPath}.${key}` : key;
            
            if (typeof value === 'string') {
                // Check for hardcoded secrets
                if (this.isSensitiveKey(key) && value.length > 10) {
                    this.addVulnerability({
                        type: VULNERABILITY_CATEGORIES.SECRETS,
                        severity: VULNERABILITY_SEVERITY.HIGH,
                        title: 'Hardcoded secret in configuration',
                        description: `Sensitive configuration key "${fullPath}" contains hardcoded value`,
                        location: `${path.relative(process.cwd(), filePath)}:${fullPath}`,
                        remediation: 'Move sensitive values to environment variables or secret management'
                    });
                }
                
                // Check for insecure URLs
                if (value.startsWith('http://') && !value.includes('localhost')) {
                    this.addVulnerability({
                        type: VULNERABILITY_CATEGORIES.CONFIGURATION,
                        severity: VULNERABILITY_SEVERITY.MEDIUM,
                        title: 'Insecure HTTP URL in configuration',
                        description: `Configuration "${fullPath}" uses insecure HTTP`,
                        location: `${path.relative(process.cwd(), filePath)}:${fullPath}`,
                        remediation: 'Use HTTPS instead of HTTP'
                    });
                }
            } else if (typeof value === 'object' && value !== null) {
                await this.scanConfigObject(filePath, value, fullPath);
            }
        }
    }
    
    /**
     * Scan configuration security
     */
    async scanConfiguration() {
        console.log('ðŸ” Scanning configuration security...');
        
        // Check security headers
        await this.checkSecurityHeaders();
        
        // Check HTTPS configuration
        await this.checkHTTPSConfig();
        
        // Check CORS configuration
        await this.checkCORSConfig();
        
        // Check CSP configuration
        await this.checkCSPConfig();
    }
    
    /**
     * Check security headers configuration
     */
    async checkSecurityHeaders() {
        const indexPath = path.join(process.cwd(), 'index.html');
        
        try {
            const content = await fs.readFile(indexPath, 'utf8');
            const requiredHeaders = [
                'X-Content-Type-Options',
                'X-Frame-Options',
                'X-XSS-Protection',
                'Strict-Transport-Security',
                'Content-Security-Policy'
            ];
            
            for (const header of requiredHeaders) {
                if (!content.includes(header)) {
                    this.addVulnerability({
                        type: VULNERABILITY_CATEGORIES.CONFIGURATION,
                        severity: VULNERABILITY_SEVERITY.MEDIUM,
                        title: `Missing security header: ${header}`,
                        description: `Security header "${header}" is not configured`,
                        location: 'index.html',
                        remediation: `Add ${header} meta tag or configure server to send header`
                    });
                }
            }
        } catch (error) {
            // No index.html file
        }
    }
    
    /**
     * Scan for exposed secrets
     */
    async scanSecrets() {
        console.log('ðŸ” Scanning for exposed secrets...');
        
        const filesToScan = await this.getFilesToScan();
        
        for (const filePath of filesToScan) {
            try {
                const content = await fs.readFile(filePath, 'utf8');
                await this.scanFileForSecrets(filePath, content);
            } catch (error) {
                // File read error
            }
        }
    }
    
    /**
     * Scan file for secrets
     */
    async scanFileForSecrets(filePath, content) {
        const secretPatterns = [
            {
                name: 'AWS Access Key',
                pattern: /AKIA[0-9A-Z]{16}/gi,
                severity: VULNERABILITY_SEVERITY.CRITICAL
            },
            {
                name: 'GitHub Token',
                pattern: /ghp_[0-9a-zA-Z]{36}/gi,
                severity: VULNERABILITY_SEVERITY.CRITICAL
            },
            {
                name: 'Private SSH Key',
                pattern: /-----BEGIN (?:RSA )?PRIVATE KEY-----/gi,
                severity: VULNERABILITY_SEVERITY.CRITICAL
            },
            {
                name: 'Google API Key',
                pattern: /AIza[0-9A-Za-z\\-_]{35}/gi,
                severity: VULNERABILITY_SEVERITY.HIGH
            },
            {
                name: 'Slack Token',
                pattern: /xox[baprs]-[0-9]{12}-[0-9]{12}-[0-9a-zA-Z]{24}/gi,
                severity: VULNERABILITY_SEVERITY.HIGH
            }
        ];
        
        for (const pattern of secretPatterns) {
            const matches = content.match(pattern.pattern);
            
            if (matches) {
                for (const match of matches) {
                    this.addVulnerability({
                        type: VULNERABILITY_CATEGORIES.SECRETS,
                        severity: pattern.severity,
                        title: `Exposed ${pattern.name}`,
                        description: `${pattern.name} found in file`,
                        location: path.relative(process.cwd(), filePath),
                        match: match.substring(0, 20) + '...',
                        remediation: 'Remove secret from code and use environment variables or secret management'
                    });
                }
            }
        }
    }
    
    /**
     * Scan file permissions
     */
    async scanPermissions() {
        console.log('ðŸ” Scanning file permissions...');
        
        const criticalFiles = [
            '.env',
            'config.json',
            'secrets.json',
            'id_rsa',
            'id_dsa'
        ];
        
        for (const fileName of criticalFiles) {
            const filePath = path.join(process.cwd(), fileName);
            
            try {
                const stats = await fs.stat(filePath);
                const mode = stats.mode & 0o777;
                
                // Check if file is world-readable
                if (mode & 0o004) {
                    this.addVulnerability({
                        type: VULNERABILITY_CATEGORIES.PERMISSIONS,
                        severity: VULNERABILITY_SEVERITY.HIGH,
                        title: 'Sensitive file is world-readable',
                        description: `File "${fileName}" has overly permissive permissions`,
                        location: fileName,
                        remediation: 'Restrict file permissions (chmod 600 or similar)'
                    });
                }
            } catch (error) {
                // File doesn't exist
            }
        }
    }
    
    /**
     * Check compliance with security standards
     */
    async checkCompliance() {
        console.log('ðŸ” Checking security compliance...');
        
        await this.checkOWASPCompliance();
        await this.checkDataProtectionCompliance();
    }
    
    /**
     * Check OWASP Top 10 compliance
     */
    async checkOWASPCompliance() {
        const owaspChecks = [
            {
                name: 'Injection Prevention',
                check: () => this.hasInjectionPrevention(),
                remediation: 'Implement input validation and parameterized queries'
            },
            {
                name: 'Broken Authentication',
                check: () => this.hasSecureAuthentication(),
                remediation: 'Implement secure authentication and session management'
            },
            {
                name: 'Sensitive Data Exposure',
                check: () => this.hasDataProtection(),
                remediation: 'Encrypt sensitive data and use secure transmission'
            },
            {
                name: 'Security Misconfiguration',
                check: () => this.hasSecureConfiguration(),
                remediation: 'Review and harden security configurations'
            },
            {
                name: 'Insufficient Logging',
                check: () => this.hasSecurityLogging(),
                remediation: 'Implement comprehensive security logging and monitoring'
            }
        ];
        
        for (const check of owaspChecks) {
            const compliant = await check.check();
            
            if (!compliant) {
                this.addVulnerability({
                    type: VULNERABILITY_CATEGORIES.COMPLIANCE,
                    severity: VULNERABILITY_SEVERITY.MEDIUM,
                    title: `OWASP: ${check.name}`,
                    description: `System does not meet OWASP standards for ${check.name}`,
                    location: 'System configuration',
                    remediation: check.remediation
                });
            }
        }
    }
    
    /**
     * Helper methods for compliance checks
     */
    async hasInjectionPrevention() {
        // Check if parameterized queries are used
        // This is a simplified check
        return true; // Placeholder
    }
    
    async hasSecureAuthentication() {
        // Check for secure authentication mechanisms
        return true; // Placeholder
    }
    
    async hasDataProtection() {
        // Check for encryption and secure data handling
        return true; // Placeholder
    }
    
    async hasSecureConfiguration() {
        // Check for secure configuration practices
        return this.vulnerabilities.filter(v => 
            v.type === VULNERABILITY_CATEGORIES.CONFIGURATION
        ).length === 0;
    }
    
    async hasSecurityLogging() {
        // Check for security logging implementation
        const securityFiles = ['security-monitor.js', 'audit.log'];
        return securityFiles.some(file => 
            this.fileExists(path.join(process.cwd(), file))
        );
    }
    
    /**
     * Run npm audit
     */
    async runNpmAudit() {
        return new Promise((resolve) => {
            const audit = spawn('npm', ['audit', '--json'], {
                cwd: process.cwd(),
                stdio: ['ignore', 'pipe', 'pipe']
            });
            
            let output = '';
            audit.stdout.on('data', (data) => {
                output += data.toString();
            });
            
            audit.on('close', (code) => {
                try {
                    resolve(JSON.parse(output));
                } catch (error) {
                    resolve({ vulnerabilities: {} });
                }
            });
            
            audit.on('error', () => {
                resolve({ vulnerabilities: {} });
            });
        });
    }
    
    /**
     * Check for known vulnerable packages
     */
    async checkVulnerablePackages(packageJson) {
        const vulnerablePackages = {
            'lodash': {
                version: '<4.17.19',
                severity: 'HIGH',
                issue: 'Prototype pollution vulnerability'
            },
            'moment': {
                version: '*',
                severity: 'MEDIUM',
                issue: 'Legacy package with security issues'
            },
            'request': {
                version: '*',
                severity: 'MEDIUM',
                issue: 'Deprecated package with security issues'
            }
        };
        
        const dependencies = {
            ...packageJson.dependencies,
            ...packageJson.devDependencies
        };
        
        for (const [name, info] of Object.entries(vulnerablePackages)) {
            if (dependencies[name]) {
                this.addVulnerability({
                    type: VULNERABILITY_CATEGORIES.DEPENDENCY,
                    severity: this.mapStringToSeverity(info.severity),
                    title: `Vulnerable package: ${name}`,
                    description: info.issue,
                    location: 'package.json',
                    remediation: 'Update to a secure version or find alternative package'
                });
            }
        }
    }
    
    /**
     * Get files to scan
     */
    async getFilesToScan() {
        const files = [];
        
        for (const scanPath of this.config.scanPaths) {
            try {
                const pathFiles = await this.getFilesRecursively(scanPath);
                files.push(...pathFiles);
            } catch (error) {
                // Path doesn't exist or not accessible
            }
        }
        
        return files.filter(file => {
            const ext = path.extname(file).toLowerCase();
            return this.config.fileExtensions.includes(ext);
        });
    }
    
    /**
     * Get files recursively
     */
    async getFilesRecursively(dirPath) {
        const files = [];
        
        try {
            const entries = await fs.readdir(dirPath, { withFileTypes: true });
            
            for (const entry of entries) {
                const fullPath = path.join(dirPath, entry.name);
                
                if (entry.isDirectory()) {
                    // Skip excluded directories
                    if (this.config.excludePaths.includes(entry.name)) {
                        continue;
                    }
                    
                    const subFiles = await this.getFilesRecursively(fullPath);
                    files.push(...subFiles);
                } else if (entry.isFile()) {
                    const stats = await fs.stat(fullPath);
                    
                    // Skip files that are too large
                    if (stats.size > this.config.maxFileSize) {
                        continue;
                    }
                    
                    files.push(fullPath);
                }
            }
        } catch (error) {
            // Directory not accessible
        }
        
        return files;
    }
    
    /**
     * Add vulnerability to results
     */
    addVulnerability(vulnerability) {
        const vuln = {
            id: crypto.randomBytes(8).toString('hex'),
            timestamp: new Date().toISOString(),
            ...vulnerability
        };
        
        this.vulnerabilities.push(vuln);
    }
    
    /**
     * Generate comprehensive report
     */
    async generateReport() {
        const report = {
            scan: {
                id: crypto.randomBytes(16).toString('hex'),
                timestamp: new Date().toISOString(),
                duration: Date.now() - this.startTime,
                scannedFiles: this.scannedFiles,
                scanPaths: this.config.scanPaths
            },
            summary: {
                totalVulnerabilities: this.vulnerabilities.length,
                ...this.getVulnerabilityCounts(),
                riskScore: this.calculateRiskScore()
            },
            vulnerabilities: this.vulnerabilities.sort((a, b) => b.severity - a.severity),
            recommendations: this.generateRecommendations(),
            compliance: {
                owasp: this.checkOWASPScore(),
                dataProtection: this.checkDataProtectionScore()
            }
        };
        
        // Save report to file
        const reportFile = path.join(
            this.config.reportPath,
            `vulnerability-scan-${Date.now()}.json`
        );
        
        await fs.writeFile(reportFile, JSON.stringify(report, null, 2));
        
        // Generate markdown report
        const markdownReport = this.generateMarkdownReport(report);
        const markdownFile = path.join(
            this.config.reportPath,
            `vulnerability-scan-${Date.now()}.md`
        );
        
        await fs.writeFile(markdownFile, markdownReport);
        
        return report;
    }
    
    /**
     * Get vulnerability counts by severity
     */
    getVulnerabilityCounts() {
        const counts = {
            critical: 0,
            high: 0,
            medium: 0,
            low: 0,
            info: 0
        };
        
        this.vulnerabilities.forEach(vuln => {
            switch (vuln.severity) {
                case VULNERABILITY_SEVERITY.CRITICAL:
                    counts.critical++;
                    break;
                case VULNERABILITY_SEVERITY.HIGH:
                    counts.high++;
                    break;
                case VULNERABILITY_SEVERITY.MEDIUM:
                    counts.medium++;
                    break;
                case VULNERABILITY_SEVERITY.LOW:
                    counts.low++;
                    break;
                default:
                    counts.info++;
            }
        });
        
        return counts;
    }
    
    /**
     * Calculate overall risk score
     */
    calculateRiskScore() {
        let score = 0;
        
        this.vulnerabilities.forEach(vuln => {
            switch (vuln.severity) {
                case VULNERABILITY_SEVERITY.CRITICAL:
                    score += 10;
                    break;
                case VULNERABILITY_SEVERITY.HIGH:
                    score += 5;
                    break;
                case VULNERABILITY_SEVERITY.MEDIUM:
                    score += 2;
                    break;
                case VULNERABILITY_SEVERITY.LOW:
                    score += 1;
                    break;
            }
        });
        
        return Math.min(score, 100);
    }
    
    /**
     * Generate recommendations
     */
    generateRecommendations() {
        const recommendations = [];
        const vulnsByType = this.groupVulnerabilitiesByType();
        
        if (vulnsByType[VULNERABILITY_CATEGORIES.SECRETS]?.length > 0) {
            recommendations.push({
                priority: 'HIGH',
                category: 'Secrets Management',
                action: 'Implement secure secrets management',
                description: 'Move all hardcoded secrets to environment variables or secure vault'
            });
        }
        
        if (vulnsByType[VULNERABILITY_CATEGORIES.DEPENDENCY]?.length > 0) {
            recommendations.push({
                priority: 'HIGH',
                category: 'Dependencies',
                action: 'Update vulnerable dependencies',
                description: 'Run npm audit fix and update to secure package versions'
            });
        }
        
        if (vulnsByType[VULNERABILITY_CATEGORIES.CODE_PATTERN]?.length > 0) {
            recommendations.push({
                priority: 'MEDIUM',
                category: 'Code Security',
                action: 'Review and fix code patterns',
                description: 'Address dangerous code patterns and implement secure alternatives'
            });
        }
        
        return recommendations;
    }
    
    /**
     * Generate markdown report
     */
    generateMarkdownReport(report) {
        let markdown = `# Vulnerability Scan Report

**Scan ID:** ${report.scan.id}
**Timestamp:** ${report.scan.timestamp}
**Duration:** ${report.scan.duration}ms
**Files Scanned:** ${report.scan.scannedFiles}

## Summary

- **Total Vulnerabilities:** ${report.summary.totalVulnerabilities}
- **Critical:** ${report.summary.critical}
- **High:** ${report.summary.high}
- **Medium:** ${report.summary.medium}
- **Low:** ${report.summary.low}
- **Risk Score:** ${report.summary.riskScore}/100

## Vulnerabilities by Severity

`;

        // Group vulnerabilities by severity
        const severityGroups = {
            'CRITICAL': report.vulnerabilities.filter(v => v.severity === VULNERABILITY_SEVERITY.CRITICAL),
            'HIGH': report.vulnerabilities.filter(v => v.severity === VULNERABILITY_SEVERITY.HIGH),
            'MEDIUM': report.vulnerabilities.filter(v => v.severity === VULNERABILITY_SEVERITY.MEDIUM),
            'LOW': report.vulnerabilities.filter(v => v.severity === VULNERABILITY_SEVERITY.LOW)
        };
        
        for (const [severity, vulns] of Object.entries(severityGroups)) {
            if (vulns.length > 0) {
                markdown += `### ${severity} Severity (${vulns.length})\n\n`;
                
                vulns.forEach(vuln => {
                    markdown += `#### ${vuln.title}\n`;
                    markdown += `- **Location:** ${vuln.location}\n`;
                    markdown += `- **Description:** ${vuln.description}\n`;
                    markdown += `- **Remediation:** ${vuln.remediation}\n`;
                    if (vuln.context) {
                        markdown += `- **Context:** \`${vuln.context}\`\n`;
                    }
                    markdown += '\n';
                });
            }
        }
        
        markdown += `## Recommendations\n\n`;
        report.recommendations.forEach(rec => {
            markdown += `### ${rec.category} (${rec.priority})\n`;
            markdown += `**Action:** ${rec.action}\n\n`;
            markdown += `${rec.description}\n\n`;
        });
        
        return markdown;
    }
    
    /**
     * Utility methods
     */
    groupVulnerabilitiesByType() {
        return this.vulnerabilities.reduce((acc, vuln) => {
            if (!acc[vuln.type]) {
                acc[vuln.type] = [];
            }
            acc[vuln.type].push(vuln);
            return acc;
        }, {});
    }
    
    getVulnerabilitySummary() {
        const counts = this.getVulnerabilityCounts();
        return `Critical: ${counts.critical}, High: ${counts.high}, Medium: ${counts.medium}, Low: ${counts.low}`;
    }
    
    checkOWASPScore() {
        const owaspVulns = this.vulnerabilities.filter(v => 
            v.type === VULNERABILITY_CATEGORIES.COMPLIANCE && v.title.includes('OWASP')
        );
        return Math.max(0, 100 - (owaspVulns.length * 10));
    }
    
    checkDataProtectionScore() {
        const secretsVulns = this.vulnerabilities.filter(v => 
            v.type === VULNERABILITY_CATEGORIES.SECRETS
        );
        return Math.max(0, 100 - (secretsVulns.length * 15));
    }
    
    mapNpmSeverity(severity) {
        const mapping = {
            'critical': VULNERABILITY_SEVERITY.CRITICAL,
            'high': VULNERABILITY_SEVERITY.HIGH,
            'moderate': VULNERABILITY_SEVERITY.MEDIUM,
            'low': VULNERABILITY_SEVERITY.LOW,
            'info': VULNERABILITY_SEVERITY.INFO
        };
        return mapping[severity] || VULNERABILITY_SEVERITY.MEDIUM;
    }
    
    mapStringToSeverity(severity) {
        const mapping = {
            'CRITICAL': VULNERABILITY_SEVERITY.CRITICAL,
            'HIGH': VULNERABILITY_SEVERITY.HIGH,
            'MEDIUM': VULNERABILITY_SEVERITY.MEDIUM,
            'LOW': VULNERABILITY_SEVERITY.LOW,
            'INFO': VULNERABILITY_SEVERITY.INFO
        };
        return mapping[severity] || VULNERABILITY_SEVERITY.MEDIUM;
    }
    
    isSensitiveKey(key) {
        const sensitiveKeys = [
            'password', 'pwd', 'pass', 'secret', 'key', 'token', 'auth',
            'api_key', 'apikey', 'private', 'credential', 'access', 'session'
        ];
        
        return sensitiveKeys.some(sensitive => 
            key.toLowerCase().includes(sensitive)
        );
    }
    
    parseYamlBasic(content) {
        // Very basic YAML parsing for security checks
        // In production, use a proper YAML parser
        const lines = content.split('\n');
        const result = {};
        
        lines.forEach(line => {
            if (line.includes(':') && !line.trim().startsWith('#')) {
                const [key, ...valueParts] = line.split(':');
                const value = valueParts.join(':').trim();
                if (key && value) {
                    result[key.trim()] = value.replace(/['"`]/g, '');
                }
            }
        });
        
        return result;
    }
    
    async fileExists(filePath) {
        try {
            await fs.access(filePath);
            return true;
        } catch {
            return false;
        }
    }
}

module.exports = {
    VulnerabilityScanner,
    VULNERABILITY_SEVERITY,
    VULNERABILITY_CATEGORIES
};