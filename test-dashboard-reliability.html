<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Data Reliability Test Suite</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
        }
        
        .test-suite {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }
        
        .test-header {
            text-align: center;
            margin-bottom: 40px;
        }
        
        .test-header h1 {
            background: linear-gradient(135deg, #6f42c1, #e83e8c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 32px;
            margin: 0;
        }
        
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .test-card {
            background: linear-gradient(135deg, #ffffff, #f8f9fa);
            border: 1px solid rgba(111, 66, 193, 0.1);
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s ease;
        }
        
        .test-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(111, 66, 193, 0.15);
        }
        
        .test-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #333;
        }
        
        .test-description {
            font-size: 14px;
            color: #666;
            margin-bottom: 15px;
            line-height: 1.5;
        }
        
        .test-button {
            background: linear-gradient(135deg, #6f42c1, #e83e8c);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }
        
        .test-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(111, 66, 193, 0.3);
        }
        
        .test-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .test-results {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 12px;
            border-left: 4px solid #6f42c1;
        }
        
        .result-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        
        .result-item:last-child {
            border-bottom: none;
        }
        
        .result-status {
            font-size: 16px;
        }
        
        .result-text {
            flex: 1;
            font-size: 14px;
        }
        
        .result-time {
            font-size: 12px;
            color: #666;
        }
        
        .dashboard-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .control-button {
            background: linear-gradient(135deg, #20c997, #17a2b8);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .control-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(32, 201, 151, 0.3);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #eee;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #6f42c1;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
    </style>
<link rel="stylesheet" href="assets/pwa-mobile.css">

<!-- Touch Optimization -->
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="theme-color" content="#2563eb">

<style>
/* Critical CSS for above-the-fold content */
.dashboard-header {
  background: var(--color-primary, #2563eb);
  color: white;
  padding: 1rem;
  position: sticky;
  top: 0;
  z-index: 100;
}

.loading-spinner {
  display: inline-block;
  width: 2rem;
  height: 2rem;
  border: 3px solid rgba(255,255,255,.3);
  border-radius: 50%;
  border-top-color: #fff;
  animation: spin 1s ease-in-out infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}
</style>

  <!-- Preload critical assets -->
  <link rel="preload" href="/assets/versioned/styles-consolidated.min.css" as="style">
  <link rel="preload" href="/assets/versioned/script-consolidated.min.js" as="script">
</head>
<body>

<a href="#main-content" class="skip-link">Skip to main content</a>
<a href="#navigation" class="skip-link">Skip to navigation</a>

<style>
.skip-link {
  position: absolute;
  top: -40px;
  left: 6px;
  background: #000;
  color: #fff;
  padding: 8px;
  text-decoration: none;
  z-index: 1000;
  border-radius: 0 0 4px 4px;
}

.skip-link:focus {
  top: 0;
}
</style>
    <div class="test-suite">
        <div class="test-header">
            <h1>üõ°Ô∏è Dashboard Data Reliability Test Suite</h1>
            <p>Comprehensive testing for bulletproof data loading architecture</p>
        </div>
        
        <div class="dashboard-controls">
            <button class="control-button" onclick="initializeDashboard()">
                üöÄ Initialize Dashboard
            </button>
            <button class="control-button" onclick="showDashboard()">
                üìä Show Dashboard
            </button>
            <button class="control-button" onclick="clearAllCaches()">
                üóëÔ∏è Clear All Caches
            </button>
            <button class="control-button" onclick="runFullTestSuite()">
                üß™ Run Full Test Suite
            </button>
        </div>
        
        <div class="test-grid">
            <div class="test-card">
                <div class="test-title">üîÑ Race Condition Prevention</div>
                <div class="test-description">
                    Tests multiple concurrent data loading requests to ensure no race conditions occur.
                </div>
                <button class="test-button" onclick="testRaceConditions()">
                    Run Race Condition Test
                </button>
            </div>
            
            <div class="test-card">
                <div class="test-title">üì∂ Network Failure Recovery</div>
                <div class="test-description">
                    Simulates network failures and validates automatic retry logic with exponential backoff.
                </div>
                <button class="test-button" onclick="testNetworkFailure()">
                    Test Network Recovery
                </button>
            </div>
            
            <div class="test-card">
                <div class="test-title">üì¶ Cache Reliability</div>
                <div class="test-description">
                    Validates cache consistency, TTL expiration, and intelligent fallback mechanisms.
                </div>
                <button class="test-button" onclick="testCacheReliability()">
                    Test Cache System
                </button>
            </div>
            
            <div class="test-card">
                <div class="test-title">‚ö° Performance Under Load</div>
                <div class="test-description">
                    Tests rapid refresh scenarios and validates <2-second recovery time requirements.
                </div>
                <button class="test-button" onclick="testPerformanceLoad()">
                    Run Performance Test
                </button>
            </div>
            
            <div class="test-card">
                <div class="test-title">üîí Data Consistency</div>
                <div class="test-description">
                    Ensures atomic data operations and validates data integrity across all scenarios.
                </div>
                <button class="test-button" onclick="testDataConsistency()">
                    Test Data Integrity
                </button>
            </div>
            
            <div class="test-card">
                <div class="test-title">üö® Graceful Degradation</div>
                <div class="test-description">
                    Validates fallback mechanisms when all data sources fail, ensuring minimal functionality.
                </div>
                <button class="test-button" onclick="testGracefulDegradation()">
                    Test Fallback Systems
                </button>
            </div>
        </div>
        
        <div class="test-results">
            <h3>üìã Test Results</h3>
            <div id="test-results-list"></div>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="tests-passed">0</div>
                    <div class="stat-label">Tests Passed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="tests-failed">0</div>
                    <div class="stat-label">Tests Failed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="avg-load-time">0ms</div>
                    <div class="stat-label">Avg Load Time</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="cache-hit-rate">0%</div>
                    <div class="stat-label">Cache Hit Rate</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load required scripts -->
    <script src="assets/development-intelligence-dashboard.js"></script>
    
    <script>
        let dashboard = null;
        let testStats = {
            passed: 0,
            failed: 0,
            loadTimes: [],
            cacheHits: 0,
            cacheAttempts: 0
        };
        
        /**
         * Initialize the dashboard for testing
         */
        async function initializeDashboard() {
            try {
                addTestResult('üöÄ Initializing Dashboard...', 'info');
                
                if (dashboard) {
                    dashboard.destroy();
                }
                
                dashboard = new DevelopmentIntelligenceDashboard({
                    owner: 'adrianwedd',
                    repo: 'cv',
                    refreshInterval: 30000,
                    maxRetries: 3,
                    retryDelay: 500,
                    requestTimeout: 5000,
                    cacheTimeout: 30000
                });
                
                // Wait for initialization
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                addTestResult('‚úÖ Dashboard initialized successfully', 'success');
                testStats.passed++;
                
            } catch (error) {
                addTestResult(`‚ùå Dashboard initialization failed: ${error.message}`, 'error');
                testStats.failed++;
            }
            
            updateStats();
        }
        
        /**
         * Show the dashboard
         */
        async function showDashboard() {
            if (!dashboard) {
                addTestResult('‚ö†Ô∏è Dashboard not initialized', 'warning');
                return;
            }
            
            try {
                await dashboard.showDashboard();
                addTestResult('üìä Dashboard opened successfully', 'success');
            } catch (error) {
                addTestResult(`‚ùå Failed to show dashboard: ${error.message}`, 'error');
            }
        }
        
        /**
         * Clear all caches
         */
        function clearAllCaches() {
            if (dashboard && dashboard.dataLoader) {
                dashboard.dataLoader.clearCache();
                dashboard.cache.clear();
                addTestResult('üóëÔ∏è All caches cleared', 'info');
            } else {
                addTestResult('‚ö†Ô∏è No dashboard available to clear cache', 'warning');
            }
        }
        
        /**
         * Test race conditions
         */
        async function testRaceConditions() {
            if (!dashboard) {
                addTestResult('‚ùå Dashboard not initialized for race condition test', 'error');
                return;
            }
            
            addTestResult('üîÑ Testing race conditions...', 'info');
            
            try {
                const startTime = Date.now();
                
                // Fire multiple concurrent requests
                const promises = Array.from({ length: 5 }, (_, i) => 
                    dashboard.loadDashboardData().catch(err => ({ error: err, index: i }))
                );
                
                const results = await Promise.allSettled(promises);
                const loadTime = Date.now() - startTime;
                
                // Check if all requests completed without conflicts
                const successful = results.filter(r => r.status === 'fulfilled' && !r.value?.error);
                
                if (successful.length >= 3) { // At least 3 should succeed due to deduplication
                    addTestResult(`‚úÖ Race condition test passed (${loadTime}ms)`, 'success');
                    testStats.passed++;
                    testStats.loadTimes.push(loadTime);
                } else {
                    addTestResult('‚ùå Race condition test failed - unexpected conflicts', 'error');
                    testStats.failed++;
                }
                
            } catch (error) {
                addTestResult(`‚ùå Race condition test error: ${error.message}`, 'error');
                testStats.failed++;
            }
            
            updateStats();
        }
        
        /**
         * Test network failure recovery
         */
        async function testNetworkFailure() {
            if (!dashboard) {
                addTestResult('‚ùå Dashboard not initialized for network test', 'error');
                return;
            }
            
            addTestResult('üì∂ Testing network failure recovery...', 'info');
            
            try {
                // Clear cache to force network requests
                dashboard.dataLoader.clearCache();
                
                const startTime = Date.now();
                
                // This will naturally fail for GitHub API due to CORS, testing fallback
                await dashboard.loadDashboardData();
                
                const loadTime = Date.now() - startTime;
                
                // Should complete with fallback data within reasonable time
                if (loadTime < 10000) { // 10 seconds max
                    addTestResult(`‚úÖ Network failure recovery successful (${loadTime}ms)`, 'success');
                    testStats.passed++;
                    testStats.loadTimes.push(loadTime);
                } else {
                    addTestResult('‚ùå Network recovery too slow', 'error');
                    testStats.failed++;
                }
                
            } catch (error) {
                addTestResult(`‚ùå Network failure test error: ${error.message}`, 'error');
                testStats.failed++;
            }
            
            updateStats();
        }
        
        /**
         * Test cache reliability
         */
        async function testCacheReliability() {
            if (!dashboard) {
                addTestResult('‚ùå Dashboard not initialized for cache test', 'error');
                return;
            }
            
            addTestResult('üì¶ Testing cache reliability...', 'info');
            
            try {
                // First load (should miss cache)
                const startTime1 = Date.now();
                await dashboard.loadDashboardData();
                const firstLoadTime = Date.now() - startTime1;
                
                // Second load (should hit cache)
                const startTime2 = Date.now();
                await dashboard.loadDashboardData();
                const secondLoadTime = Date.now() - startTime2;
                
                // Cache hit should be significantly faster
                if (secondLoadTime < firstLoadTime * 0.5) {
                    addTestResult(`‚úÖ Cache working correctly (${secondLoadTime}ms vs ${firstLoadTime}ms)`, 'success');
                    testStats.passed++;
                    testStats.cacheHits++;
                } else {
                    addTestResult('‚ùå Cache not improving performance', 'error');
                    testStats.failed++;
                }
                
                testStats.cacheAttempts += 2;
                testStats.loadTimes.push(firstLoadTime, secondLoadTime);
                
            } catch (error) {
                addTestResult(`‚ùå Cache test error: ${error.message}`, 'error');
                testStats.failed++;
            }
            
            updateStats();
        }
        
        /**
         * Test performance under load
         */
        async function testPerformanceLoad() {
            if (!dashboard) {
                addTestResult('‚ùå Dashboard not initialized for performance test', 'error');
                return;
            }
            
            addTestResult('‚ö° Testing performance under load...', 'info');
            
            try {
                const iterations = 3;
                const loadTimes = [];
                
                for (let i = 0; i < iterations; i++) {
                    dashboard.dataLoader.clearCache();
                    
                    const startTime = Date.now();
                    await dashboard.loadDashboardData();
                    const loadTime = Date.now() - startTime;
                    
                    loadTimes.push(loadTime);
                    
                    // Brief pause between iterations
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                const avgLoadTime = loadTimes.reduce((sum, time) => sum + time, 0) / loadTimes.length;
                const maxLoadTime = Math.max(...loadTimes);
                
                // Should meet <2-second recovery requirement
                if (avgLoadTime < 2000 && maxLoadTime < 5000) {
                    addTestResult(`‚úÖ Performance test passed (avg: ${Math.round(avgLoadTime)}ms, max: ${maxLoadTime}ms)`, 'success');
                    testStats.passed++;
                } else {
                    addTestResult(`‚ùå Performance test failed (avg: ${Math.round(avgLoadTime)}ms, max: ${maxLoadTime}ms)`, 'error');
                    testStats.failed++;
                }
                
                testStats.loadTimes.push(...loadTimes);
                
            } catch (error) {
                addTestResult(`‚ùå Performance test error: ${error.message}`, 'error');
                testStats.failed++;
            }
            
            updateStats();
        }
        
        /**
         * Test data consistency
         */
        async function testDataConsistency() {
            if (!dashboard) {
                addTestResult('‚ùå Dashboard not initialized for consistency test', 'error');
                return;
            }
            
            addTestResult('üîí Testing data consistency...', 'info');
            
            try {
                // Load data multiple times and verify consistency
                const results = [];
                
                for (let i = 0; i < 3; i++) {
                    await dashboard.loadDashboardData();
                    const cached = dashboard.cache.get('dashboard_data');
                    if (cached && cached.intelligence) {
                        results.push(cached.intelligence.executive.overallScore);
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // All results should be consistent (or at least reasonable)
                const allValid = results.every(score => typeof score === 'number' && score >= 0);
                
                if (allValid && results.length === 3) {
                    addTestResult(`‚úÖ Data consistency verified (scores: ${results.join(', ')})`, 'success');
                    testStats.passed++;
                } else {
                    addTestResult(`‚ùå Data consistency failed (results: ${results})`, 'error');
                    testStats.failed++;
                }
                
            } catch (error) {
                addTestResult(`‚ùå Data consistency test error: ${error.message}`, 'error');
                testStats.failed++;
            }
            
            updateStats();
        }
        
        /**
         * Test graceful degradation
         */
        async function testGracefulDegradation() {
            if (!dashboard) {
                addTestResult('‚ùå Dashboard not initialized for degradation test', 'error');
                return;
            }
            
            addTestResult('üö® Testing graceful degradation...', 'info');
            
            try {
                // Clear all caches to force fresh requests
                dashboard.dataLoader.clearCache();
                dashboard.cache.clear();
                
                // Simulate total failure by temporarily breaking the loader
                const originalFetch = window.fetch;
                window.fetch = () => Promise.reject(new Error('Simulated network failure'));
                
                const startTime = Date.now();
                
                try {
                    await dashboard.loadDashboardData();
                } catch (error) {
                    // Expected to fail, but should handle gracefully
                }
                
                // Restore fetch
                window.fetch = originalFetch;
                
                const loadTime = Date.now() - startTime;
                
                // Should fail gracefully within reasonable time
                if (loadTime < 15000) { // 15 seconds max for failure handling
                    addTestResult(`‚úÖ Graceful degradation successful (${loadTime}ms)`, 'success');
                    testStats.passed++;
                } else {
                    addTestResult('‚ùå Graceful degradation too slow', 'error');
                    testStats.failed++;
                }
                
            } catch (error) {
                addTestResult(`‚ùå Graceful degradation test error: ${error.message}`, 'error');
                testStats.failed++;
            }
            
            updateStats();
        }
        
        /**
         * Run full test suite
         */
        async function runFullTestSuite() {
            addTestResult('üß™ Starting full test suite...', 'info');
            
            // Reset stats
            testStats = {
                passed: 0,
                failed: 0,
                loadTimes: [],
                cacheHits: 0,
                cacheAttempts: 0
            };
            
            document.getElementById('test-results-list').innerHTML = '';
            
            // Initialize dashboard first
            await initializeDashboard();
            
            // Run all tests sequentially
            await testRaceConditions();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testNetworkFailure();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testCacheReliability();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testPerformanceLoad();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testDataConsistency();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testGracefulDegradation();
            
            // Final results
            const totalTests = testStats.passed + testStats.failed;
            const successRate = totalTests > 0 ? Math.round((testStats.passed / totalTests) * 100) : 0;
            
            addTestResult(`üèÅ Test suite completed: ${testStats.passed}/${totalTests} passed (${successRate}%)`, 
                         successRate >= 80 ? 'success' : 'error');
        }
        
        /**
         * Add test result to display
         */
        function addTestResult(message, type = 'info') {
            const resultsList = document.getElementById('test-results-list');
            const resultItem = document.createElement('div');
            resultItem.className = 'result-item';
            
            const statusIcon = {
                'success': '‚úÖ',
                'error': '‚ùå',
                'warning': '‚ö†Ô∏è',
                'info': '‚ÑπÔ∏è'
            }[type] || '‚ÑπÔ∏è';
            
            resultItem.innerHTML = `
                <span class="result-status">${statusIcon}</span>
                <span class="result-text">${message}</span>
                <span class="result-time">${new Date().toLocaleTimeString()}</span>
            `;
            
            resultsList.appendChild(resultItem);
            resultsList.scrollTop = resultsList.scrollHeight;
        }
        
        /**
         * Update statistics display
         */
        function updateStats() {
            document.getElementById('tests-passed').textContent = testStats.passed;
            document.getElementById('tests-failed').textContent = testStats.failed;
            
            const avgLoadTime = testStats.loadTimes.length > 0 
                ? Math.round(testStats.loadTimes.reduce((sum, time) => sum + time, 0) / testStats.loadTimes.length)
                : 0;
            document.getElementById('avg-load-time').textContent = avgLoadTime + 'ms';
            
            const cacheHitRate = testStats.cacheAttempts > 0 
                ? Math.round((testStats.cacheHits / testStats.cacheAttempts) * 100)
                : 0;
            document.getElementById('cache-hit-rate').textContent = cacheHitRate + '%';
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            addTestResult('üìã Reliability test suite ready', 'info');
            addTestResult('üí° Click "Initialize Dashboard" to begin testing', 'info');
        });
    </script>

<script>
// Offline/online detection
function updateConnectionStatus() {
  const isOnline = navigator.onLine;
  const indicator = document.getElementById('connection-indicator') || createConnectionIndicator();
  
  if (isOnline) {
    indicator.textContent = 'üåê Online';
    indicator.className = 'connection-indicator online';
  } else {
    indicator.textContent = 'üì¥ Offline';
    indicator.className = 'connection-indicator offline';
  }
}

function createConnectionIndicator() {
  const indicator = document.createElement('div');
  indicator.id = 'connection-indicator';
  indicator.style.cssText = `
    position: fixed;
    bottom: 20px;
    left: 20px;
    padding: 0.5rem 1rem;
    border-radius: 0.25rem;
    font-size: 0.875rem;
    z-index: 1000;
    transition: all 0.3s ease;
  `;
  document.body.appendChild(indicator);
  return indicator;
}

window.addEventListener('online', updateConnectionStatus);
window.addEventListener('offline', updateConnectionStatus);
document.addEventListener('DOMContentLoaded', updateConnectionStatus);
</script>

<main role="main" id="main-content" aria-label="Dashboard content">
  <!-- Main dashboard content -->
</main>

<nav role="navigation" id="navigation" aria-label="Dashboard navigation">
  <!-- Navigation content -->
</nav>

<script>
// Enhanced focus management
document.addEventListener('keydown', (e) => {
  // Trap focus in modal dialogs
  if (e.key === 'Tab') {
    const activeModal = document.querySelector('.modal[aria-hidden="false"]');
    if (activeModal) {
      trapFocus(e, activeModal);
    }
  }
  
  // Keyboard navigation
  if (e.key === 'Escape') {
    closeAllModals();
  }
});

function trapFocus(e, container) {
  const focusableElements = container.querySelectorAll(
    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
  );
  
  const firstElement = focusableElements[0];
  const lastElement = focusableElements[focusableElements.length - 1];
  
  if (e.shiftKey && document.activeElement === firstElement) {
    lastElement.focus();
    e.preventDefault();
  } else if (!e.shiftKey && document.activeElement === lastElement) {
    firstElement.focus();
    e.preventDefault();
  }
}

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.altKey) {
    switch(e.key) {
      case 'h':
        document.querySelector('h1').focus();
        break;
      case 'm':
        document.querySelector('main').focus();
        break;
      case 'n':
        document.querySelector('nav').focus();
        break;
    }
  }
});
</script>
</body>
</html>